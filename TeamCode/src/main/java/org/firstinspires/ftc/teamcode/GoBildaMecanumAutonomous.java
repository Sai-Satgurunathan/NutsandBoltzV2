// Code Generated by Sidekick is for learning and experimentation purposes only.
package org.firstinspires.ftc.teamcode;

import static com.qualcomm.robotcore.hardware.DcMotor.ZeroPowerBehavior.BRAKE;

import com.qualcomm.robotcore.eventloop.opmode.LinearOpMode;
import com.qualcomm.robotcore.hardware.CRServo;
import com.qualcomm.robotcore.hardware.DcMotor;
import com.qualcomm.robotcore.hardware.DcMotorEx;
import com.qualcomm.robotcore.hardware.DcMotorSimple;
import com.qualcomm.robotcore.hardware.PIDFCoefficients;
import com.qualcomm.robotcore.util.ElapsedTime;

@com.qualcomm.robotcore.eventloop.opmode.Autonomous(name="GoBilda Mecanum Autonomous", group="Linear Opmode")
public class GoBildaMecanumAutonomous extends LinearOpMode {

    private DcMotor frontLeft, frontRight, backLeft, backRight;

    final double FEED_TIME_SECONDS = 2.50; //The feeder servos run this long when a shot is requested.
    final double STOP_SPEED = 0.0; //We send this power to the servos when we want them to stop.
    final double FULL_SPEED = 1.0;

    final double LAUNCHER_TARGET_VELOCITY = 1300;
    final double LAUNCHER_MIN_VELOCITY = 1250;
    private DcMotorEx launcher = null;
    private CRServo leftFeeder = null;
    private CRServo rightFeeder = null;
    ElapsedTime feederTimer = new ElapsedTime();

    private enum LaunchState {
        IDLE,
        SPIN_UP,
        LAUNCH,
        LAUNCHING,
        DONE,
    }

    private LaunchState launchState;

    @Override
    public void runOpMode() {
        launchState = LaunchState.IDLE;

        // Initialize motors
        frontLeft = hardwareMap.dcMotor.get("left_front_drive");
        frontRight = hardwareMap.dcMotor.get("right_front_drive");
        backLeft = hardwareMap.dcMotor.get("left_back_drive");
        backRight = hardwareMap.dcMotor.get("right_back_drive");
        launcher = hardwareMap.get(DcMotorEx.class, "launcher");
        leftFeeder = hardwareMap.get(CRServo.class, "left_feeder");
        rightFeeder = hardwareMap.get(CRServo.class, "right_feeder");

        // Reverse the right side motors if necessary
        frontRight.setDirection(DcMotor.Direction.REVERSE);
        backRight.setDirection(DcMotor.Direction.REVERSE);

        /*
         * Launcher configuration
         */
        launcher.setMode(DcMotor.RunMode.RUN_USING_ENCODER);
        launcher.setPIDFCoefficients(DcMotor.RunMode.RUN_USING_ENCODER, new PIDFCoefficients(300, 0, 0, 10));
        launcher.setZeroPowerBehavior(BRAKE);


        // Set initial motor modes
        frontLeft.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);
        frontRight.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);
        backLeft.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);
        backRight.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);

        /*
         * Initialize feeders
         */
        leftFeeder.setPower(STOP_SPEED);
        rightFeeder.setPower(STOP_SPEED);
        leftFeeder.setDirection(DcMotorSimple.Direction.REVERSE);

        telemetry.addData("Status", "Autonomous Initialized");

        // Wait for the game to start (driver presses PLAY)
        waitForStart();

        // Move forward 26 inches
        moveInches(26, 0.5, MoveDirection.FORWARD);


        while (launchState != LaunchState.DONE)
        {
            launch();
        }

        // Move forward 26 inches
        moveInches(26, 0.5, MoveDirection.FORWARD);

        // Strafe right 12 inches
        moveInches(18, 0.5, MoveDirection.RIGHT);


        // Rotate 90 degrees clockwise
        //rotateDegrees(90, 0.5);

        // Move backward 12 inches
        //moveInches(12, 0.5, MoveDirection.BACKWARD);
    }

    private void launch()
    {
        telemetry.addData("Status", ""+launchState);
        switch (launchState) {
            case IDLE:
                //if (shotRequested) {
                    launchState = LaunchState.SPIN_UP;
                  //  sleep(2000);
                //}
                break;
            case SPIN_UP:
                launcher.setVelocity(LAUNCHER_TARGET_VELOCITY);
                if (launcher.getVelocity() > LAUNCHER_MIN_VELOCITY) {
                    launchState = LaunchState.LAUNCH;
                }
                break;
            case LAUNCH:
                leftFeeder.setPower(FULL_SPEED);
                rightFeeder.setPower(FULL_SPEED);
                feederTimer.reset();
                launchState = LaunchState.LAUNCHING;
                break;
            case LAUNCHING:
                if (feederTimer.seconds() > FEED_TIME_SECONDS) {
                    launchState = LaunchState.IDLE;
                    leftFeeder.setPower(STOP_SPEED);
                    rightFeeder.setPower(STOP_SPEED);
                    launchState = LaunchState.DONE;
                }
                break;
        }
    }


    enum MoveDirection { FORWARD, BACKWARD, LEFT, RIGHT }

    private void moveInches(double inches, double power, MoveDirection direction) {
        int countsPerRevolution = 537; // GoBilda yellow jacket 312rpm motor, adjust as needed
        double wheelDiameterInches = 4.0; // Standard mecanum wheels
        double countsPerInch = countsPerRevolution / (Math.PI * wheelDiameterInches);

        int targetCounts = (int)(inches * countsPerInch);

        int flTarget = 0, frTarget = 0, blTarget = 0, brTarget = 0;

        switch(direction) {
            case FORWARD:
                flTarget = targetCounts;
                frTarget = targetCounts;
                blTarget = targetCounts;
                brTarget = targetCounts;
                break;
            case BACKWARD:
                flTarget = -targetCounts;
                frTarget = -targetCounts;
                blTarget = -targetCounts;
                brTarget = -targetCounts;
                break;
            case LEFT: // Strafe
                flTarget = -targetCounts;
                frTarget = targetCounts;
                blTarget = targetCounts;
                brTarget = -targetCounts;
                break;
            case RIGHT: // Strafe
                flTarget = targetCounts;
                frTarget = -targetCounts;
                blTarget = -targetCounts;
                brTarget = targetCounts;
                break;
        }

        frontLeft.setTargetPosition(frontLeft.getCurrentPosition() + flTarget);
        frontRight.setTargetPosition(frontRight.getCurrentPosition() + frTarget);
        backLeft.setTargetPosition(backLeft.getCurrentPosition() + blTarget);
        backRight.setTargetPosition(backRight.getCurrentPosition() + brTarget);

        frontLeft.setMode(DcMotor.RunMode.RUN_TO_POSITION);
        frontRight.setMode(DcMotor.RunMode.RUN_TO_POSITION);
        backLeft.setMode(DcMotor.RunMode.RUN_TO_POSITION);
        backRight.setMode(DcMotor.RunMode.RUN_TO_POSITION);

        frontLeft.setPower(power);
        frontRight.setPower(power);
        backLeft.setPower(power);
        backRight.setPower(power);

        while (opModeIsActive() && (frontLeft.isBusy() && frontRight.isBusy() && backLeft.isBusy() && backRight.isBusy())) {
            idle();
        }

        frontLeft.setPower(0);
        frontRight.setPower(0);
        backLeft.setPower(0);
        backRight.setPower(0);
    }

    private void rotateDegrees(double degrees, double power) {
        //  For 360 degrees, estimate wheel base to get encoder counts
        double robotCircumference = 15.7; //  Assume robot turn circumference (inches), adjust based on your robot
        double turnInches = robotCircumference * (degrees / 360.0);

        int countsPerRevolution = 537;
        double wheelDiameterInches = 4.0;
        double countsPerInch = countsPerRevolution / (Math.PI * wheelDiameterInches);
        int targetCounts = (int)(turnInches * countsPerInch);

        frontLeft.setTargetPosition(frontLeft.getCurrentPosition() + targetCounts);
        frontRight.setTargetPosition(frontRight.getCurrentPosition() - targetCounts);
        backLeft.setTargetPosition(backLeft.getCurrentPosition() + targetCounts);
        backRight.setTargetPosition(backRight.getCurrentPosition() - targetCounts);

        frontLeft.setMode(DcMotor.RunMode.RUN_TO_POSITION);
        frontRight.setMode(DcMotor.RunMode.RUN_TO_POSITION);
        backLeft.setMode(DcMotor.RunMode.RUN_TO_POSITION);
        backRight.setMode(DcMotor.RunMode.RUN_TO_POSITION);

        frontLeft.setPower(power);
        frontRight.setPower(power);
        backLeft.setPower(power);
        backRight.setPower(power);

        while (opModeIsActive() && (frontLeft.isBusy() && frontRight.isBusy() && backLeft.isBusy() && backRight.isBusy())) {
            idle();
        }

        frontLeft.setPower(0);
        frontRight.setPower(0);
        backLeft.setPower(0);
        backRight.setPower(0);

    }
}
